/**
 * (99 Проблем в Scala) Урок #05 - Перевернуть список
 * @see https://www.thedigitalcatonline.com/blog/2015/04/07/99-scala-problems-05-reverse
 */

/*
 * Процедурное решение
 * ***
 * Тип List предоставляет встроенный метод reverse() для возврата перевернутой копии списка
 * Но такой метод не переворачивает этот список, а возвращает новый список
 */
def reverse1[A](ls: List[A]) = ls.reverse

reverse1( List(0,1,2,3,4,5,6,7,8,9) )

/*
 * Операторы конкатенации списков в Scala
 * ***
 * Оператор двойного двоеточия :: добавляет элемент в начало списка
 * (Существуют `префиксные` операции и `инфиксные` операции)
 */
val l1 = List(2,3,4,5,6)
1 :: l1 //TODO   val res1: List[Int] = List(1, 2, 3, 4, 5, 6)

//val l = List(1, 2, 3, 4)
//l(0)

/*
 * Операторы конкатенации списков в Scala
 * ***
 * Еще в Scala, такой оператор двойного двоеточия :: это как нечто что отделяет головной элемент списка от хвостового элемента
 * в данном случае `tail` это свободная переменная-типа-список, поэтому сопоставление будет всегда выполнятся
 * поэтому любое первое сопоставление будет успешным и головной элемент списка всегда будет первым элементом
 * (здесь речь идет об `инфиксных` операциях)
 *
 *
 * пытается сопоставить входящее List(1,2,3,4) с чем-то в форме h::tail,
 * что означает «список с одним элементом в заголовке и концом списка».
 * Использование :: оператора гарантирует, что он h будет считаться одним элементом.
 *
 * Дело в том, что :: в Scala также есть класс, производный от List который создается с передачей одного элемента и списка.
 * Это означает, что приведенный выше пример можно явно записать как
 *
 * Таким образом, хотя эффект один и тот же, существует разница между :: методом List объектов и :: классом, используемым при сопоставлении с образцом.
 *
 * Также помните, что в Scala методы, имена которых заканчиваются на, : являются право-ассоциативными
 * Это означает, что 0 :: List(1,2,3) это сокращенная форма для List(1,2,3).::(0)
 */
val res21 = List(1, 2, 3, 4) match { //TODO   val res21: Any = 1
  case (h :: tail) => h
  case _ => Nil
}
val res22 = List(1, 2, 3, 4) match { //TODO   val res22: List[Int] = List(2, 3, 4)
  case (h :: tail) => tail
  case _ => Nil
}
val res23 = List(1, 2, 3, 4) match { //TODO   val res23: List[Int] = List(1, 2, 3, 4)
  case l => l
  case _ => Nil
}
/*
 * И ::: наоборот, оператор тройного двоеточия - это просто метод List объектов,
 * (и класса с таким именем не существует)
 * Он добавляет целый список к другому списку (объединяет списки), и завершение : им также является право-ассоциативным методом
 */
List(4,5,6) ::: List(1,2,3)
List(1,2,3).:::(List(4,5,6))


/*
 * В Scala, когда пишем сопоставление с образцом - это не только сравнение с образцом, но еще и присваивание
 * сначала нужно попытаться сопоставить `5` с `a` и в случае успеха Scala присваивает значение `5` переменной `a`
 * в данном случае `a` это свободная переменная, поэтому сопоставление будет всегда выполнятся
 */
val res3 = 5 match { //TODO   val res2: Int = 6
  case a => a + 1
}



/*
 * Рекурсивное решение
 * ***
 * Теперь рекурсивное решение становится более ясным:
 * первый случай сопоставления с образцом просто меняет местами заголовок списка с хвостом,
 * но рекурсивно вызывает функцию самого хвоста.
 *
 * Но как уже объяснялось, этот код не является хвостовой рекурсией,
 * таким образом выделяется большое пространство стека для хранения локальных переменных во время рекурсивного вызова
 */
def reverse2[A] (ls: List[A]): List[A] = ls match {
  case (h :: tail) => reverse2(tail) ::: List(h) //TODO   `List(2, 3, 4)` + `List(1)`  ||  поскольку в Scala `return` компилятором выводится автоматом, поэтому в такой рекурсии возвращаться всегда будет case с не-нулевым значением...
  case Nil => Nil //TODO   `Nil` - это всегда нулевой и последний элемент списка
}

reverse2( List(1,2,3,4,5,6) ) //TODO   val res4: List[Int] = List(6, 5, 4, 3, 2, 1)

/*
 * Хороший способ сделать его хвостовой рекурсией - использовать другой список, который заполняется элементами, извлеченными из исходного
 * Здесь используем вспомогательную функцию `_reverse`, в которой мы выбираем первый элемент из оставшегося списка `rem`
 * И добавляем его в начало списка, созданного с нуля
 *
 * Первое решение, наоборот, давало результат рекурсии в качестве входных данных для метода :::()
 * А при рекурсивном вызове в стеке не остается никаких вычислений
 */
def reverse3[A] (ls: List[A]): List[A] = {
  def _reverse(res: List[A], rem: List[A]): List[A] = rem match {
    case Nil => res
    case (h :: tail) => _reverse(h :: res, tail) //TODO   _reverse(`List(1)`, `List(2, 3, 4)`)
  }
  _reverse(Nil, ls)
}

reverse3( List(1,2,3,4,5,6) ) //TODO   val res5: List[Int] = List(6, 5, 4, 3, 2, 1)



/*
 * функция foldLeft() принимает предыдущий результат и текущий элемент...
 */