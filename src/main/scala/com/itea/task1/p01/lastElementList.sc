/**
 * (99 Проблем в Scala) Урок #01 - Найти последний элемент списка
 * @see https://www.thedigitalcatonline.com/blog/2015/04/07/99-scala-problems-01-find-last-element
 */


/*
 * Самая первая проблема Scala, может ли и как Scala работать с универсальными контейнерами (то есть списком, независимо от типа содержимого).
 *
 *
 * Синтаксис языка, имеет много возможностей и некоторые темные углы, но ясно, что:
 * - входные параметры должны быть указаны в круглых скобках
 * - а тип вывода идет после них (вне скобок)
 * - Затем знак равенства и тело функции в фигурных скобках
 * Знак равенства имеет важное значение, отсутствие знака равенства приводит к тому, что функция автоматически возвращает Unit тип (то есть без вывода),
 * поэтому, суть в следующем: должна ли ваша функция что-то возвращать или нет.
 *
 * Функция, которая принимает список любых вещей - подпадает под термин полиморфизм, и в Scala ее можно решить с помощью переменных типа.
 * где стартовый тип [A] - это сигнал о том, что функция представляет собой своего рода шаблон со свободным типом A, на данный момент неизвестным.
 * Этот же тип используется позже, чтобы сказать, что параметр `ls` является одним List из вещей
 * и `A` является типом каждой из них.
 * Наконец, эта функция возвращает одно значение типа `A`
 */

def func[A] (ls: List[A]): A = {
  ???
}

/*
 * Процедурное решение
 * ***
 * состоит в том, чтобы просто перебирать список, в котором хранится последний посещенный элемент, до тех пор, пока не будет достигнут конец функции.
 * В этот момент последний посещенный элемент также является последним элементом списка.
 *
 * Здесь нет проверки на пустой список, потому что метод last() уже выдает NoSuchElementException когда элемент отсутствует.
 * И здесь нет необходимости явно использовать оператор return, поскольку функции всегда возвращают последнее выражение.
 */
def last1[A] (ls: List[A]): A = ls.last

last1( List(0,1,2,3,4,5,6) ) // val res0: Int = 6


/*
 * Рекурсивное решение
 * ***
 * Первый шаблон делит список на две части: один элемент головы и хвост (Nil)
 *
 * Второй шаблон берет только хвост списка (а первый элемент он игнорируется используя подстановочный знак `_`) и рекурсивно вызывает себя для оставшихся элементов
 */
def last2[A] (ls: List[A]): A = ls match {
  case (head :: Nil) => head
  case (_ :: tail) => last2(tail)
  case _ => throw new NoSuchElementException
}

last2( List(0,1,2,3,4,5,6) ) // val res1: Int = 6