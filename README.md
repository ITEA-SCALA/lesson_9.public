# Небольшое введение в Scalatest

* https://habr.com/ru/post/209578

**ScalaTest** — ( www.scalatest.org ) это фреймворк для тестирования приложений, поддерживающий разные стили написания тестов.

Каждый из поддерживаемых стилей тестирования в **Scalatest** создан для использования в определенных целях.

---

Для использования каждого из стилей тестирования, необходимо создать класс, который будет реализовывать trait, в котором определён этот стиль тестирования.

Выбранный стиль определяет только то, как выглядят декларации тестов, все остальные возможности фреймворка будут работать одинаково, вне зависимости от того, какой из стилей тестирования был выбран.

---

### FlatSpec

**FlatSpec** — используют для юнит-тестов и для интеграционного тестирования.

**FlatSpec** это DSL позволяющий писать тесты в виде как можно более приближённом к написанию спецификации поведения тестируемого класса.

- **Assertions** в каждом стиле по умолчанию доступно 3 ассерта:
  - `assert` — для обычных проверок
  - `assertResult` — для проверки совпадения полученного и ожидаемого результата
  - `intercept` — для проверки что метод бросает ожидаемое исключение
- **Matchers**
  - `be` — одно из ключевых слов, которое можно использовать если подключить миксин *Matchers* в класс (который реализует тест)
- **Равенство** размер объекта, длина объекта
- **Проверка строк**
- **Проверка чисел**
- **Проверка булевых свойств**
- **Коллекции**
- **Свойства класса**
- **Соединение проверок логическими функциями**


### FeatureSpec

**FeatureSpec** — используют для приемочного тестирования.

**FeatureSpec** нацелен на создание приемочных тестов, облегчая программистам задачу работающим с не тестировщиками.


## Scala with Cats (Scala – Introduction to Cats)

* [Конспект по Scala with Cats](https://blog.maizy.ru/posts/scala-cats-summary)
* 1000 разных подходов к определению, монада – механизм для последовательных вычислений операции
  * **.pure(a)** – создание монадического контекста из сырого значения
  * **.flatMap(f)** – извлечение значения из контекста и создание следующего контекста в последовательности
* любая монада – функтор, map легко построить из pure+flatMap
* laws:
  * **левоассоциативность:** pure(a).flatMap(f) == f(a). тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.
  * **правоассоциативность:** m.flatMap(pure) == m.
  * **ассоциативность:** m.flatMap(f).flatMap(g) == m.flatMap(x => f(x).flatMap(g))
    * syntax:
      * .pure[T] (из cats.syntax.applicative)
      * .map(f) (из cats.syntax.functor)
      * .flatMap(f) (из cats.syntax.flatMap)
      * можно использовать for comprehensions из scala
  * при определении своих монад
    * .flatMap
    * .pure
    * .tailRecM – оптимизация для вложенных .flatMap вызовов. метод можно делать @tailrec


### Монада — это моноид в категории эндофункторов

* `Виталий Брагилевский * Монады не приговор`: https://www.youtube.com/watch?v=IkXg_mjNgG4

### Реализация
1. должна быть возможность туда поместить значение с помощью фабричных методов или конструкторов
2. применить операцию `map` для преобазования данных
3. и реализовать связывание с помощью операции `flatMap` (которая представляет из себя: применить какую-то операцию но не применять глубоко вложенные контейнеры)

**(** Простейший пример: монада `Option` (Scala), она же `Maybe` (Haskell) **)**

* `Кирилл Бяков (Туту.ру) * О монадах по-человечески`: https://www.youtube.com/watch?v=-aXZnNY2NNw

* `Иван Гришаев * Монады`: https://www.youtube.com/watch?v=5-yjqPQH_fU


---

[Ссылка на запись 8 занятия](https://us02web.zoom.us/rec/share/MhCUP09CEzc7EZxNyu85ut-qnSqRZfkXj3djDZXHLTeCkDmT143l2t56ZoFBYELs.r1XE9mi1J7D-sl5c)

* `Scala Docs` https://github.com/Home-SCALA2/docs

